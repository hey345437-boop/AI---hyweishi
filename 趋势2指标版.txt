//@version=6
indicator("趋势2指标版", shorttitle="山寨高频小周期", overlay=true, max_lines_count=500, max_boxes_count=500, max_labels_count=500, precision=2)

// ============================================================================
//                         第一部分：何以为底 (UI置顶)
// ============================================================================

// 1. 信号模式选择
modeInput_bottom = input.string("平衡模式", title="信号模式", 
     options=["保守模式", "平衡模式", "激进模式", "恶魔模式"], 
     tooltip="保守模式：最稳定\n平衡模式：信号增加\n激进模式：信号更多，误差更大\n恶魔模式：信号最多，误差也最大", group="顶底信号")

// 2. 实时模式开关
realTimeMode_bottom = input.bool(false, title="启用实时显示模式 (会导致重绘)", 
     tooltip="警告：\n1. 勾选后，信号只要盘中满足条件就会立即出现，不等待收盘。\n2. 这会导致'重绘'现象（即信号可能在盘中出现，若收盘时条件不再满足则会消失）。\n3. 若用于实盘交易，建议保持关闭（默认），以收盘确认信号为主。\n4. 勾选后警报也会变为实时触发。", group="顶底信号")

// 根据模式映射回原来的逻辑变量
var bool more_bottom = false
var int choose_bottom = 1

// 使用 switch 语句进行模式分配
switch modeInput_bottom
    "保守模式" => 
        more_bottom := false
        choose_bottom := 0 
    "平衡模式" => 
        more_bottom := true
        choose_bottom := 1
    "激进模式" => 
        more_bottom := true
        choose_bottom := 2
    "恶魔模式" => 
        more_bottom := true
        choose_bottom := 3

// ———— Stoch + KDJ ————
int periodK_bottom = 14
int smoothK_bottom = 5
int overSoldLevel_bottom = 20
int overBoughtLevel_bottom = 80
int ilong_bottom = 9
int isig_bottom = 3

// 1. Stochastic %K 计算
k_bottom = ta.sma(ta.stoch(close, high, low, periodK_bottom), smoothK_bottom)

// 2. KDJ (GM_V2) 计算
bcwsma_bottom(series, length, m) =>
    float _bcwsma = na
    _bcwsma := (m * series + (length - m) * nz(_bcwsma[1])) / length

rsv_bottom = 100 * (close - ta.lowest(low, ilong_bottom)) / (ta.highest(high, ilong_bottom) - ta.lowest(low, ilong_bottom))
pK_bottom = bcwsma_bottom(rsv_bottom, isig_bottom, 1)
pD_bottom = bcwsma_bottom(pK_bottom, isig_bottom, 1)

// 信号条件
stochOversold_bottom = k_bottom < overSoldLevel_bottom  
stochOverbought_bottom = k_bottom > overBoughtLevel_bottom  
kdj_golden_cross_bottom = ta.crossover(pK_bottom, pD_bottom)  
kdj_death_cross_bottom = ta.crossunder(pK_bottom, pD_bottom)  

// 组合信号
smi_kdj_buy_bottom = stochOversold_bottom and kdj_golden_cross_bottom  
smi_kdj_sell_bottom = stochOverbought_bottom and kdj_death_cross_bottom  

// ==================== OBV-ADX  ====================
len_bottom = 22
lensig_bottom = 22

up_bottom = ta.change(ta.obv)
down_bottom = -ta.change(ta.obv)
plusDM_bottom = na(up_bottom) ? na : up_bottom > down_bottom and up_bottom > 0 ? up_bottom : 0
minusDM_bottom = na(down_bottom) ? na : down_bottom > up_bottom and down_bottom > 0 ? down_bottom : 0
trur_bottom = ta.rma(ta.stdev(ta.obv, len_bottom), len_bottom)
plus_bottom = fixnan(100 * ta.ema(plusDM_bottom, len_bottom) / trur_bottom)
minus_bottom = fixnan(100 * ta.ema(minusDM_bottom, len_bottom) / trur_bottom)
sum_bottom = plus_bottom + minus_bottom
adx_bottom = 100 * ta.ema(math.abs(plus_bottom - minus_bottom) / (sum_bottom == 0 ? 1 : sum_bottom), lensig_bottom)

obv_adx_buy_bottom = minus_bottom >= 22 and adx_bottom >= 22 and plus_bottom <= 18  
obv_adx_sell_bottom = plus_bottom >= 22 and minus_bottom <= 18 and adx_bottom >= 22 

// ==================== 组合信号逻辑 ====================
// 核心修改：如果开启实时模式，则始终为true；否则必须等待K线确认
triggerState_bottom = realTimeMode_bottom ? true : barstate.isconfirmed

basic_buy_signal_bottom = triggerState_bottom and smi_kdj_buy_bottom and obv_adx_buy_bottom
basic_sell_signal_bottom = triggerState_bottom and smi_kdj_sell_bottom and obv_adx_sell_bottom

var int obv_buy_bar_bottom = na
var int obv_sell_bar_bottom = na

// 在实时模式下，这里的变量更新可能会导致重绘，属于预期行为
if triggerState_bottom and obv_adx_buy_bottom
    obv_buy_bar_bottom := bar_index

if triggerState_bottom and obv_adx_sell_bottom
    obv_sell_bar_bottom := bar_index

extended_buy_signal_bottom = false
extended_sell_signal_bottom = false

if more_bottom
    extended_buy_signal_bottom := triggerState_bottom and smi_kdj_buy_bottom and not na(obv_buy_bar_bottom) and (bar_index - obv_buy_bar_bottom) <= choose_bottom
    extended_sell_signal_bottom := triggerState_bottom and smi_kdj_sell_bottom and not na(obv_sell_bar_bottom) and (bar_index - obv_sell_bar_bottom) <= choose_bottom

combined_buy_signal_bottom = basic_buy_signal_bottom or extended_buy_signal_bottom
combined_sell_signal_bottom = basic_sell_signal_bottom or extended_sell_signal_bottom

// ==================== 绘制信号 ====================
if combined_buy_signal_bottom
    label.new(bar_index, low, "底", 
              color=color.green, textcolor=color.white, 
              style=label.style_label_up, yloc=yloc.belowbar)
    
if combined_sell_signal_bottom
    label.new(bar_index, high, "顶", 
              color=color.red, textcolor=color.white, 
              style=label.style_label_down, yloc=yloc.abovebar)

// ==================== 警报条件 (动态切换) ====================

// 精简警报消息
msg_buy_bottom = "底 " + str.tostring(close)
msg_sell_bottom = "顶 " + str.tostring(close)

if combined_buy_signal_bottom
    if realTimeMode_bottom
        // 实时模式：条件满足立即报警，但在同一根K线上只报一次 (freq_once_per_bar)
        alert(msg_buy_bottom, alert.freq_once_per_bar)
    else
        // 默认模式：必须等K线收盘才报警 (freq_once_per_bar_close)
        alert(msg_buy_bottom, alert.freq_once_per_bar_close)

if combined_sell_signal_bottom
    if realTimeMode_bottom
        alert(msg_sell_bottom, alert.freq_once_per_bar)
    else
        alert(msg_sell_bottom, alert.freq_once_per_bar_close)


// ============================================================================
//                         新增部分：高频顶底
// ============================================================================
enable_hf = input.bool(false, title="启用高频顶底功能", group="高频信号", tooltip="注意：启用后将有更多顶底信号，适合震荡行情，单边行情下请谨慎使用。")

// *** 新增：实时模式开关 (参数隐藏版) ***
realTimeMode_hf = input.bool(false, title="启用实时显示模式 (会导致重绘)", 
     tooltip="警告：\n1. 勾选后，信号只要盘中满足条件就会立即出现，不等待收盘。\n2. 这会导致'重绘'现象（即信号可能在盘中出现，若收盘时条件不再满足则会消失）。\n3. 若用于实盘交易，建议保持关闭（默认），以收盘确认信号为主。\n4. 勾选后警报也会变为实时触发。", group="高频信号")

// --- RCI Ribbon Settings (参数固定隐藏) ---
rciShortLen_hf = 10
rciMidLen_hf   = 30
rciShort_hf = ta.rci(close, rciShortLen_hf)
rciMid_hf   = ta.rci(close, rciMidLen_hf)
rciOverbought_hf = 80
rciOversold_hf   = -80

// --- Stochastic Settings (参数固定隐藏) ---
stochKLen_hf    = 14
stochKSmooth_hf = 5
stochDSmooth_hf = 3
k_hf = ta.sma(ta.stoch(close, high, low, stochKLen_hf), stochKSmooth_hf)
d_hf = ta.sma(k_hf, stochDSmooth_hf)
stochOverbought_hf = 80
stochOversold_hf   = 20

// --- KDJ Settings (参数固定隐藏) ---
kdjLong_hf = 4
kdjSig_hf  = 3
h_val_hf = ta.highest(high, kdjLong_hf)
l_val_hf = ta.lowest(low, kdjLong_hf)
RSV_hf   = 100 * ((close - l_val_hf) / (h_val_hf - l_val_hf))
pK_hf = bcwsma_bottom(RSV_hf, kdjSig_hf, 1) // 复用之前的函数
pD_hf = bcwsma_bottom(pK_hf,  kdjSig_hf, 1)
pJ_hf = 3 * pK_hf - 2 * pD_hf

// --- Signal Logic (受实时开关控制) ---
triggerState_hf = realTimeMode_hf ? true : barstate.isconfirmed

isOverboughtZone_hf = rciShort_hf > rciOverbought_hf and rciMid_hf > rciOverbought_hf and k_hf > stochOverbought_hf and d_hf > stochOverbought_hf
isOversoldZone_hf   = rciShort_hf < rciOversold_hf and rciMid_hf < rciOversold_hf and k_hf < stochOversold_hf and d_hf < stochOversold_hf


cross_up_hf = ta.crossover(pJ_hf, pD_hf)
cross_dn_hf = ta.crossunder(pJ_hf, pD_hf)


shortSignal_hf = enable_hf and triggerState_hf and isOverboughtZone_hf and cross_dn_hf
longSignal_hf  = enable_hf and triggerState_hf and isOversoldZone_hf   and cross_up_hf


// --- Plotting ---
plotshape(shortSignal_hf, title = "HighFreq Short", style = shape.labeldown, location = location.abovebar, color = color.red,   text = "SHORT", textcolor = color.white, size = size.small)
plotshape(longSignal_hf,  title = "HighFreq Long",  style = shape.labelup,   location = location.belowbar, color = color.green, text = "LONG",  textcolor = color.white, size = size.small)

// --- Alert (警报自动切换) ---
if shortSignal_hf
    if realTimeMode_hf
        alert("short " + str.tostring(close), alert.freq_once_per_bar)
    else
        alert("short " + str.tostring(close), alert.freq_once_per_bar_close)

if longSignal_hf
    if realTimeMode_hf
        alert("long " + str.tostring(close), alert.freq_once_per_bar)
    else
        alert("long " + str.tostring(close), alert.freq_once_per_bar_close)


// ============================================================================
//                         第二部分：趋势2.3 (已修改为仅收盘显示)
// ============================================================================

// 交易模式 (固定)
tradeMode_trend = "多空双做" 

// --- 止盈/止损变量 (保留定义，不移除逻辑) ---
tpMasterEnable_trend = false 
tpUseOriginal_trend = false 
tpOriginalPct_trend = 1.0 
tpUseInternalOB_trend = false 
tpUseSwingOB_trend = false 
tpUseKeltner_trend = false 
tpKeltnerMult_trend = 3.0 
slMasterEnable_trend = false 
slUseOriginal_trend = false 
slOriginalPct_trend = 1.0 
slUseInternalOB_trend = false 
slUseSwingOB_trend = false 
atrSlEnable_trend = false 
atrLen_trend = 14 
atrSmooth_trend = "RMA" 
atrMult_trend = 1.5 
tpUseFixedRR_trend = false 
tpFixedRR_trend = 2.0 
autoPlotTrades_trend = true 
slEnabled_trend = slMasterEnable_trend or atrSlEnable_trend 

// --- 警报设置 ---
enableAlerts_trend = true 
alertPrefix_trend = input.string("TRADE", "警报前缀", group="警报设置")

// --- 策略参数 (固定) ---
rsiLen_trend = 14
rsiOversold_trend = 30
rsiOverbought_trend = 70
oscillatorFilter_trend = input.bool(false, title="启用震荡过滤器", group="大周期使用才开启")
oscillatorLength_trend = 20 

// --- SMC 设置 (仅保留开关) ---
styleInput_trend = 'Colored'
showInternalsInput_trend       = input.bool(false, '显示内部结构', group="SMC 设置")
showInternalBullInput_trend = 'All'
internalBullColorInput_trend = #089981
showInternalBearInput_trend = 'All'
internalBearColorInput_trend = #F23645
internalFilterConfluenceInput_trend = false
internalStructureSize_trend = size.tiny

showStructureInput_trend       = input.bool(true,  '显示摆动结构', group="SMC 设置")
showSwingBullInput_trend = 'All'
swingBullColorInput_trend = #089981
showSwingBearInput_trend = 'All'
swingBearColorInput_trend = #F23645
swingStructureSize_trend = size.small
swingsLengthInput_trend = 50

showInternalOrderBlocksInput_trend = input.bool(false, '显示内部订单块', group="SMC 设置")
internalOrderBlocksSizeInput_trend = 5
internalBullishOrderBlockColor_trend = color.new(#3179f5, 85)
internalBearishOrderBlockColor_trend = color.new(#f77c80, 85)

showSwingOrderBlocksInput_trend = input.bool(true,  '显示摆动订单块', group="SMC 设置")
swingOrderBlocksSizeInput_trend = 5
swingOBWidthAdjust_trend = true
swingOBWidthMultiplier_trend = 0.1
orderBlockFilterInput_trend = 'Atr'
orderBlockMitigationInput_trend = 'High/Low'

// *** 颜色配置 ***
swingBullishOrderBlockColor_trend = color.new(#2962ff, 85) 
swingBearishOrderBlockColor_trend = color.new(#ff5252, 85) 
MONO_BULLISH_trend = #b2b5be
MONO_BEARISH_trend = #5d606b

// ==========================================
// 2. VWAP 第三组轨道 (逻辑保留)
// ==========================================
devUp3_trend = 2.51 
devDn3_trend = 2.51 

dailyTime_trend = request.security(syminfo.tickerid, "D", time) 
var float vwapsum_trend = 0.0    
var float volumesum_trend = 0.0  
var float v2sum_trend = 0.0      

vwapsum_trend := dailyTime_trend != dailyTime_trend[1] ? hl2 * volume : vwapsum_trend[1] + hl2 * volume 
volumesum_trend := dailyTime_trend != dailyTime_trend[1] ? volume : volumesum_trend[1] + volume
v2sum_trend := dailyTime_trend != dailyTime_trend[1] ? volume * hl2 * hl2 : v2sum_trend[1] + volume * hl2 * hl2

myvwap_trend = vwapsum_trend / volumesum_trend 
variance_trend = (v2sum_trend / volumesum_trend) - (myvwap_trend * myvwap_trend) 
dev_trend = math.sqrt(math.max(variance_trend, 0)) 

VWAP_U3_trend = myvwap_trend + devUp3_trend * dev_trend 
VWAP_D3_trend = myvwap_trend - devDn3_trend * dev_trend 

plot(VWAP_U3_trend, title="VWAP Upper 3 (Danger)", color=color.new(#ff5252, 52), style=plot.style_line, linewidth=2)
plot(VWAP_D3_trend, title="VWAP Lower 3 (Danger)", color=color.new(#4caf4f, 50), style=plot.style_line, linewidth=2)

// ==========================================
// 3. 核心信号逻辑 (完全保留原计算)
// ==========================================
len_trend = 14
TrueRange_trend = math.max(math.max(high - low, math.abs(high - nz(close[1]))), math.abs(low - nz(close[1])))
DirectionalMovementPlus_trend = (high - nz(high[1])) > (nz(low[1]) - low) ? math.max(high - nz(high[1]), 0) : 0
DirectionalMovementMinus_trend = (nz(low[1]) - low) > (high - nz(high[1])) ? math.max(nz(low[1]) - low, 0) : 0
var float SmoothedTrueRange_trend = 0.0
SmoothedTrueRange_trend := nz(SmoothedTrueRange_trend[1]) - (nz(SmoothedTrueRange_trend[1]) / len_trend) + TrueRange_trend
var float SmoothedDirectionalMovementPlus_trend = 0.0
SmoothedDirectionalMovementPlus_trend := nz(SmoothedDirectionalMovementPlus_trend[1]) - (nz(SmoothedDirectionalMovementPlus_trend[1]) / len_trend) + DirectionalMovementPlus_trend
var float SmoothedDirectionalMovementMinus_trend = 0.0
SmoothedDirectionalMovementMinus_trend := nz(SmoothedDirectionalMovementMinus_trend[1]) - (nz(SmoothedDirectionalMovementMinus_trend[1]) / len_trend) + DirectionalMovementMinus_trend
DIPlus_trend = SmoothedDirectionalMovementPlus_trend / SmoothedTrueRange_trend * 100
DIMinus_trend = SmoothedDirectionalMovementMinus_trend / SmoothedTrueRange_trend * 100
DX_trend = math.abs(DIPlus_trend - DIMinus_trend) / (DIPlus_trend + DIMinus_trend) * 100
ADX_trend = ta.wma(DX_trend, len_trend)
adxSlope_trend = ADX_trend - ADX_trend[1]
trendMarket_trend = ADX_trend > oscillatorLength_trend and adxSlope_trend > 0

ema12_trend = ta.ema(close, 12)
fast_a_trend = ta.ema(close, 144), fast_b_trend = ta.ema(close, 169)
fast_top_trend = math.max(fast_a_trend, fast_b_trend), fast_bot_trend = math.min(fast_a_trend, fast_b_trend)
slow_a_trend = ta.ema(close, 576), slow_b_trend = ta.ema(close, 676)
slow_top_trend = math.max(slow_a_trend, slow_b_trend), slow_bot_trend = math.min(slow_a_trend, slow_b_trend)

[macdLine_trend, macdSignal_trend, macdHist_trend] = ta.macd(close, 13, 34, 9)
rsi_trend = ta.rsi(close, rsiLen_trend)

bullishTrend_trend = ema12_trend > fast_top_trend and ema12_trend > slow_top_trend
bearishTrend_trend = ema12_trend < fast_bot_trend and ema12_trend < slow_bot_trend

macdBelowFirstRise_trend = macdHist_trend < 0 and macdHist_trend > macdHist_trend[1] and macdHist_trend[1] < macdHist_trend[2]
macdAboveFirstFall_trend = macdHist_trend > 0 and macdHist_trend < macdHist_trend[1] and macdHist_trend[1] > macdHist_trend[2]

rsiCrossUpOversold_trend = ta.crossover(rsi_trend, rsiOversold_trend)
rsiCrossDownOverbought_trend = ta.crossunder(rsi_trend, rsiOverbought_trend)

longSignal_trend = macdBelowFirstRise_trend and (rsi_trend > 50 or rsiCrossUpOversold_trend)
shortSignal_trend = macdAboveFirstFall_trend and (rsi_trend < 50 or rsiCrossDownOverbought_trend)

buyCondition_trend = (oscillatorFilter_trend ? trendMarket_trend : true) and bullishTrend_trend and longSignal_trend
sellCondition_trend = (oscillatorFilter_trend ? trendMarket_trend : true) and bearishTrend_trend and shortSignal_trend

// ============= 绘图逻辑 (修改：增加 barstate.isconfirmed 强制收盘确认) =============
// 只有当 K 线收盘确认后 (isconfirmed) 才允许绘制信号
longPlot_trend = barstate.isconfirmed and buyCondition_trend and (tradeMode_trend == "多空双做" or tradeMode_trend == "仅开多单")
shortPlot_trend = barstate.isconfirmed and sellCondition_trend and (tradeMode_trend == "多空双做" or tradeMode_trend == "仅开空单")

plotshape(longPlot_trend, title="多头买点", style=shape.triangleup, location=location.belowbar, size=size.small, color=color.green)
plotshape(shortPlot_trend, title="空头卖点", style=shape.triangledown, location=location.abovebar, size=size.small, color=color.red)

// 警报
if enableAlerts_trend
    if longPlot_trend
        alert("趋势多 " + str.tostring(close), alert.freq_once_per_bar_close)
    
    if shortPlot_trend
        alert("趋势空 " + str.tostring(close), alert.freq_once_per_bar_close)


// ============================================================================
// SMC 逻辑区 (代码完全保留)
// ============================================================================
BULLISH_LEG_trend = 1
BEARISH_LEG_trend = 0
BULLISH_trend = +1
BEARISH_trend = -1
COLORED_trend = 'Colored'
MONOCHROME_trend = 'Monochrome'
ALL_trend = 'All'
BOS_trend = '突破'
CHOCH_trend = '反转'
TINY_trend = size.tiny
SMALL_trend = size.small
NORMAL_trend = size.normal
ATR_trend = 'Atr'
RANGE_trend = 'Cumulative Mean Range'
CLOSE_trend = 'Close'
HIGHLOW_trend = 'High/Low'

type pivot_trend
    float currentLevel
    float lastLevel
    bool crossed
    int barTime
    int barIndex

type trend_trend
    int bias

type orderBlock_trend
    float barHigh
    float barLow
    int barTime
    int bias

var pivot_trend swingHigh_trend = pivot_trend.new(na, na, false, na, na)
var pivot_trend swingLow_trend = pivot_trend.new(na, na, false, na, na)
var pivot_trend internalHigh_trend = pivot_trend.new(na, na, false, na, na)
var pivot_trend internalLow_trend = pivot_trend.new(na, na, false, na, na)
var trend_trend swingTrend_trend = trend_trend.new(0)
var trend_trend internalTrend_trend = trend_trend.new(0)

var array<float> parsedHighs_trend = array.new<float>()
var array<float> parsedLows_trend = array.new<float>()
var array<int> times_trend = array.new<int>()
var array<orderBlock_trend> swingOrderBlocks_trend = array.new<orderBlock_trend>()
var array<orderBlock_trend> internalOrderBlocks_trend = array.new<orderBlock_trend>()
var array<box> swingOrderBlocksBoxes_trend = array.new<box>()
var array<box> internalOrderBlocksBoxes_trend = array.new<box>()

if barstate.isfirst
    if showSwingOrderBlocksInput_trend
        for i = 1 to swingOrderBlocksSizeInput_trend
            swingOrderBlocksBoxes_trend.push(box.new(na, na, na, na, xloc=xloc.bar_time, extend=extend.right))
    if showInternalOrderBlocksInput_trend
        for i = 1 to internalOrderBlocksSizeInput_trend
            internalOrderBlocksBoxes_trend.push(box.new(na, na, na, na, xloc=xloc.bar_time, extend=extend.right))

atrMeasure_trend = ta.atr(200)
volatilityMeasure_trend = orderBlockFilterInput_trend == ATR_trend ? atrMeasure_trend : ta.cum(ta.tr) / bar_index
highVolatilityBar_trend = (high - low) >= (2 * volatilityMeasure_trend)
parsedHigh_trend = highVolatilityBar_trend ? low : high
parsedLow_trend = highVolatilityBar_trend ? high : low
parsedHighs_trend.push(parsedHigh_trend)
parsedLows_trend.push(parsedLow_trend)
times_trend.push(time)

leg_trend(int size) =>
    var theLeg = 0
    newLegHigh = high[size] > ta.highest(size)
    newLegLow = low[size] < ta.lowest(size)
    if newLegHigh
        theLeg := BEARISH_LEG_trend
    else if newLegLow
        theLeg := BULLISH_LEG_trend
    theLeg

startOfNewLeg_trend(int l) => ta.change(l) != 0
startOfBearishLeg_trend(int l) => ta.change(l) == -1
startOfBullishLeg_trend(int l) => ta.change(l) == +1

getCurrentStructure_trend(int size, bool internal) =>
    currentLeg = leg_trend(size)
    newPivot = startOfNewLeg_trend(currentLeg)
    pivotLow = startOfBullishLeg_trend(currentLeg)
    pivotHigh = startOfBearishLeg_trend(currentLeg)
    if newPivot
        if pivotLow
            if internal
                internalLow_trend.lastLevel := internalLow_trend.currentLevel
                internalLow_trend.currentLevel := low[size]
                internalLow_trend.crossed := false
                internalLow_trend.barTime := time[size]
                internalLow_trend.barIndex := bar_index[size]
            else
                swingLow_trend.lastLevel := swingLow_trend.currentLevel
                swingLow_trend.currentLevel := low[size]
                swingLow_trend.crossed := false
                swingLow_trend.barTime := time[size]
                swingLow_trend.barIndex := bar_index[size]
        else
            if internal
                internalHigh_trend.lastLevel := internalHigh_trend.currentLevel
                internalHigh_trend.currentLevel := high[size]
                internalHigh_trend.crossed := false
                internalHigh_trend.barTime := time[size]
                internalHigh_trend.barIndex := bar_index[size]
            else
                swingHigh_trend.lastLevel := swingHigh_trend.currentLevel
                swingHigh_trend.currentLevel := high[size]
                swingHigh_trend.crossed := false
                swingHigh_trend.barTime := time[size]
                swingHigh_trend.barIndex := bar_index[size]

drawStructure_trend(bool isHigh, bool internal, string tag, color structureColor, string labelSize) =>
    var line l = line.new(na, na, na, na, xloc=xloc.bar_time, color=structureColor, style=internal ? line.style_dashed : line.style_solid)
    var label lb = label.new(na, na, xloc=xloc.bar_index, text=tag, color=color.new(structureColor, 100), textcolor=structureColor, style=isHigh ? label.style_label_down : label.style_label_up, size=labelSize)
    if internal
        if isHigh
            line.set_xy1(l, internalHigh_trend.barTime, internalHigh_trend.currentLevel)
            line.set_xy2(l, time, internalHigh_trend.currentLevel)
            label.set_xy(lb, math.round(0.5*(internalHigh_trend.barIndex+bar_index)), internalHigh_trend.currentLevel)
        else
            line.set_xy1(l, internalLow_trend.barTime, internalLow_trend.currentLevel)
            line.set_xy2(l, time, internalLow_trend.currentLevel)
            label.set_xy(lb, math.round(0.5*(internalLow_trend.barIndex+bar_index)), internalLow_trend.currentLevel)
    else
        if isHigh
            line.set_xy1(l, swingHigh_trend.barTime, swingHigh_trend.currentLevel)
            line.set_xy2(l, time, swingHigh_trend.currentLevel)
            label.set_xy(lb, math.round(0.5*(swingHigh_trend.barIndex+bar_index)), swingHigh_trend.currentLevel)
        else
            line.set_xy1(l, swingLow_trend.barTime, swingLow_trend.currentLevel)
            line.set_xy2(l, time, swingLow_trend.currentLevel)
            label.set_xy(lb, math.round(0.5*(swingLow_trend.barIndex+bar_index)), swingLow_trend.currentLevel)

storeOrdeBlock_trend(bool isHighBreak, bool internal, int bias) =>
    if (internal and showInternalOrderBlocksInput_trend) or (not internal and showSwingOrderBlocksInput_trend)
        int baseIndex = isHighBreak ? (internal ? internalHigh_trend.barIndex : swingHigh_trend.barIndex) : (internal ? internalLow_trend.barIndex : swingLow_trend.barIndex)
        array<float> arr = na
        int parsedIndex = na
        if bias == BEARISH_trend
            arr := parsedHighs_trend.slice(baseIndex, bar_index)
            parsedIndex := baseIndex + arr.indexof(arr.max())
        else
            arr := parsedLows_trend.slice(baseIndex, bar_index)
            parsedIndex := baseIndex + arr.indexof(arr.min())
        
        float originalHigh = parsedHighs_trend.get(parsedIndex)
        float originalLow = parsedLows_trend.get(parsedIndex)
        
        float finalHigh = originalHigh
        float finalLow = originalLow
        
        if not internal and swingOBWidthAdjust_trend
            float expansion = atrMeasure_trend * swingOBWidthMultiplier_trend
            finalHigh := originalHigh + expansion
            finalLow := originalLow - expansion
        
        orderBlock_trend ob = orderBlock_trend.new(finalHigh, finalLow, times_trend.get(parsedIndex), bias)
        array<orderBlock_trend> target = internal ? internalOrderBlocks_trend : swingOrderBlocks_trend
        if target.size() >= 100
            target.pop()
        target.unshift(ob)

bearishOrderBlockMitigationSource_trend = orderBlockMitigationInput_trend == CLOSE_trend ? close : high
bullishOrderBlockMitigationSource_trend = orderBlockMitigationInput_trend == CLOSE_trend ? close : low

deleteOrderBlocks_trend(bool internal=false) =>
    array<orderBlock_trend> obs = internal ? internalOrderBlocks_trend : swingOrderBlocks_trend
    for [idx, ob] in obs
        crossed = false
        if bearishOrderBlockMitigationSource_trend > ob.barHigh and ob.bias == BEARISH_trend
            crossed := true
        else if bullishOrderBlockMitigationSource_trend < ob.barLow and ob.bias == BULLISH_trend
            crossed := true
        if crossed
            obs.remove(idx)

drawOrderBlocks_trend(bool internal=false) =>
    array<orderBlock_trend> obs = internal ? internalOrderBlocks_trend : swingOrderBlocks_trend
    n = obs.size()
    if n > 0
        maxN = internal ? internalOrderBlocksSizeInput_trend : swingOrderBlocksSizeInput_trend
        array<orderBlock_trend> slice = obs.slice(0, math.min(maxN, n))
        array<box> pool = internal ? internalOrderBlocksBoxes_trend : swingOrderBlocksBoxes_trend
        for [i, ob] in slice
            color c = na
            if styleInput_trend == MONOCHROME_trend
                c := ob.bias == BEARISH_trend ? color.new(MONO_BEARISH_trend, 80) : color.new(MONO_BULLISH_trend, 80)
            else
                if internal
                    c := ob.bias == BEARISH_trend ? internalBearishOrderBlockColor_trend : internalBullishOrderBlockColor_trend
                else
                    c := ob.bias == BEARISH_trend ? swingBearishOrderBlockColor_trend : swingBullishOrderBlockColor_trend
            box b = pool.get(i)
            b.set_top_left_point(chart.point.new(ob.barTime, na, ob.barHigh))
            b.set_bottom_right_point(chart.point.new(last_bar_time, na, ob.barLow))
            b.set_border_color(internal ? na : c)
            b.set_bgcolor(c)

displayStructure_trend(bool internal=false) =>
    var bullishBar = true
    var bearishBar = true
    if internal and internalFilterConfluenceInput_trend
        bullishBar := high - math.max(close, open) > math.min(close, open - low)
        bearishBar := high - math.max(close, open) < math.min(close, open - low)
    float highLevel = internal ? internalHigh_trend.currentLevel : swingHigh_trend.currentLevel
    bool highCross = ta.crossover(close, highLevel)
    bool highNotCrossed = internal ? not internalHigh_trend.crossed : not swingHigh_trend.crossed
    bool extraUp = internal ? (internalHigh_trend.currentLevel != swingHigh_trend.currentLevel and bullishBar) : true
    if highCross and highNotCrossed and extraUp
        string tag = (internal ? internalTrend_trend.bias : swingTrend_trend.bias) == BEARISH_trend ? CHOCH_trend : BOS_trend
        if internal
            internalHigh_trend.crossed := true
            internalTrend_trend.bias := BULLISH_trend
        else
            swingHigh_trend.crossed := true
            swingTrend_trend.bias := BULLISH_trend
        bool displayCond = false
        if internal
            displayCond := showInternalsInput_trend and (showInternalBullInput_trend == ALL_trend or (showInternalBullInput_trend == BOS_trend and tag != CHOCH_trend) or (showInternalBullInput_trend == CHOCH_trend and tag == CHOCH_trend))
        else
            displayCond := showStructureInput_trend and (showSwingBullInput_trend == ALL_trend or (showSwingBullInput_trend == BOS_trend and tag != CHOCH_trend) or (showSwingBullInput_trend == CHOCH_trend and tag == CHOCH_trend))
        if displayCond
            drawStructure_trend(true, internal, tag, styleInput_trend == MONOCHROME_trend ? MONO_BULLISH_trend : (internal ? internalBullColorInput_trend : swingBullColorInput_trend), internal ? internalStructureSize_trend : swingStructureSize_trend)
        if (internal and showInternalOrderBlocksInput_trend) or (not internal and showSwingOrderBlocksInput_trend)
            storeOrdeBlock_trend(true, internal, BULLISH_trend)

    float lowLevel = internal ? internalLow_trend.currentLevel : swingLow_trend.currentLevel
    bool lowCross = ta.crossunder(close, lowLevel)
    bool lowNotCrossed = internal ? not internalLow_trend.crossed : not swingLow_trend.crossed
    bool extraDn = internal ? (internalLow_trend.currentLevel != swingLow_trend.currentLevel and bearishBar) : true
    if lowCross and lowNotCrossed and extraDn
        string tag2 = (internal ? internalTrend_trend.bias : swingTrend_trend.bias) == BULLISH_trend ? CHOCH_trend : BOS_trend
        if internal
            internalLow_trend.crossed := true
            internalTrend_trend.bias := BEARISH_trend
        else
            swingLow_trend.crossed := true
            swingTrend_trend.bias := BEARISH_trend
        bool displayCond2 = false
        if internal
            displayCond2 := showInternalsInput_trend and (showInternalBearInput_trend == ALL_trend or (showInternalBearInput_trend == BOS_trend and tag2 != CHOCH_trend) or (showInternalBearInput_trend == CHOCH_trend and tag2 == CHOCH_trend))
        else
            displayCond2 := showStructureInput_trend and (showSwingBearInput_trend == ALL_trend or (showSwingBearInput_trend == BOS_trend and tag2 != CHOCH_trend) or (showSwingBearInput_trend == CHOCH_trend and tag2 == CHOCH_trend))
        if displayCond2
            drawStructure_trend(false, internal, tag2, styleInput_trend == MONOCHROME_trend ? MONO_BEARISH_trend : (internal ? internalBearColorInput_trend : swingBearColorInput_trend), internal ? internalStructureSize_trend : swingStructureSize_trend)
        if (internal and showInternalOrderBlocksInput_trend) or (not internal and showSwingOrderBlocksInput_trend)
            storeOrdeBlock_trend(false, internal, BEARISH_trend)

getCurrentStructure_trend(swingsLengthInput_trend, false)
getCurrentStructure_trend(5, true)

if showInternalsInput_trend or showInternalOrderBlocksInput_trend
    displayStructure_trend(true)
if showStructureInput_trend or showSwingOrderBlocksInput_trend
    displayStructure_trend(false)
if showInternalOrderBlocksInput_trend
    deleteOrderBlocks_trend(true)
if showSwingOrderBlocksInput_trend
    deleteOrderBlocks_trend(false)

if barstate.islastconfirmedhistory or barstate.islast
    if showInternalOrderBlocksInput_trend
        drawOrderBlocks_trend(true)
    if showSwingOrderBlocksInput_trend
        drawOrderBlocks_trend(false)

// ============================================================================
// 逻辑保留区：TP/SL (变量计算保留)
// ============================================================================
var array<int> ignoredSwingOBTimes_trend = array.new<int>()
keltnerLength_trend = 20
atrVal_trend = ta.atr(10)
keltnerMid_trend = ta.ema(close, keltnerLength_trend)
keltnerTpLower_trend = keltnerMid_trend - tpKeltnerMult_trend * atrVal_trend
keltnerTpUpper_trend = keltnerMid_trend + tpKeltnerMult_trend * atrVal_trend

obOverlapsBar_trend(orderBlock_trend ob) =>
    high >= ob.barLow and low <= ob.barHigh

getNearestOBTpPrice_trend(bool internal, bool isLong) =>
    array<orderBlock_trend> obs = internal ? internalOrderBlocks_trend : swingOrderBlocks_trend
    int sz = obs.size()
    if sz <= 0
        na
    else
        int maxN = internal ? internalOrderBlocksSizeInput_trend : swingOrderBlocksSizeInput_trend
        int n = math.min(sz, maxN)
        float best = na
        float bestDist = na
        for i = 0 to n - 1
            orderBlock_trend ob = obs.get(i)
            bool okBias = isLong ? (ob.bias == BEARISH_trend) : (ob.bias == BULLISH_trend)
            bool shouldIgnore = false
            if not internal and ignoredSwingOBTimes_trend.size() > 0
                shouldIgnore := ignoredSwingOBTimes_trend.includes(ob.barTime)
            if okBias and not shouldIgnore
                float level = isLong ? ob.barLow : ob.barHigh
                bool directionOk = isLong ? (level >= close) : (level <= close)
                if directionOk
                    float d = math.abs(level - close)
                    if na(bestDist) or d < bestDist
                        bestDist := d
                        best := level
        best

getNearestOBSlPrice_trend(bool internal, bool isLong) =>
    array<orderBlock_trend> obs = internal ? internalOrderBlocks_trend : swingOrderBlocks_trend
    int sz = obs.size()
    if sz <= 0
        na
    else
        int maxN = internal ? internalOrderBlocksSizeInput_trend : swingOrderBlocksSizeInput_trend
        int n = math.min(sz, maxN)
        float best = na
        float bestDist = na
        for i = 0 to n - 1
            orderBlock_trend ob = obs.get(i)
            bool okBias = isLong ? (ob.bias == BULLISH_trend) : (ob.bias == BEARISH_trend)
            bool shouldIgnore = false
            if not internal and ignoredSwingOBTimes_trend.size() > 0
                shouldIgnore := ignoredSwingOBTimes_trend.includes(ob.barTime)
            if okBias and not shouldIgnore
                float level = ob.barLow
                bool directionOk = isLong ? (level <= close) : (level >= close)
                if directionOk
                    float d = math.abs(level - close)
                    if na(bestDist) or d < bestDist
                        bestDist := d
                        best := level
        best

atr_ma_function_trend(src, len) =>
    atrSmooth_trend == "RMA" ? ta.rma(src, len) : atrSmooth_trend == "SMA" ? ta.sma(src, len) : atrSmooth_trend == "EMA" ? ta.ema(src, len) : ta.wma(src, len)

atrTR_trend    = ta.tr(true)
atrBase_trend  = atr_ma_function_trend(atrTR_trend, atrLen_trend)
atrA_trend     = atrBase_trend * atrMult_trend
atrShort_trend = high + atrA_trend    
atrLong_trend  = low  - atrA_trend    

var float atrFixedLong_trend  = na 
var float atrFixedShort_trend = na 
var int   lastPosDir_trend    = 0
// 这里的 posDir 仅为占位符，因策略逻辑已移除，故不更新
posDir_trend = 0 
bool newLong_trend = posDir_trend == 1 and lastPosDir_trend != 1 
bool newShort_trend = posDir_trend == -1 and lastPosDir_trend != -1 

if atrSlEnable_trend
    if newLong_trend
        atrFixedLong_trend := atrLong_trend  
    if newShort_trend
        atrFixedShort_trend := atrShort_trend 

if newLong_trend or newShort_trend
    ignoredSwingOBTimes_trend.clear()
    int maxN = swingOrderBlocksSizeInput_trend
    int sz = swingOrderBlocks_trend.size()
    int n = math.min(sz, maxN)
    for i = 0 to n - 1
        orderBlock_trend ob = swingOrderBlocks_trend.get(i)
        if obOverlapsBar_trend(ob)
            ignoredSwingOBTimes_trend.push(ob.barTime)

if posDir_trend == 0 and lastPosDir_trend != 0
    ignoredSwingOBTimes_trend.clear()

lastPosDir_trend := posDir_trend

// ==========================================
// 右上角表格提示
// ==========================================
var table infoTable = table.new(position.top_right, 2, 7, border_width=1, border_color=color.new(color.gray, 80), bgcolor=color.new(color.black, 50))

if barstate.islast
    table.cell(infoTable, 0, 0, "图例说明", text_color=color.white, bgcolor=color.new(color.gray, 50), text_size=size.small, width=12)
    table.cell(infoTable, 1, 0, "含义", text_color=color.white, bgcolor=color.new(color.gray, 50), text_size=size.small, width=12)
    
    table.cell(infoTable, 0, 1, "▲ (绿色)", text_color=color.green, text_size=size.small)
    table.cell(infoTable, 1, 1, "做多信号", text_color=color.white, text_size=size.small)
    
    table.cell(infoTable, 0, 2, "▼ (红色)", text_color=color.red, text_size=size.small)
    table.cell(infoTable, 1, 2, "做空信号", text_color=color.white, text_size=size.small)
    
    table.cell(infoTable, 0, 3, "红---绿线条以外", text_color=color.new(#ffffff, 0), text_size=size.small)
    table.cell(infoTable, 1, 3, "危险区域", text_color=color.white, text_size=size.small)
    
    table.cell(infoTable, 0, 4, "----", text_color=swingBearishOrderBlockColor_trend, text_size=size.small, bgcolor=swingBearishOrderBlockColor_trend)
    table.cell(infoTable, 1, 4, "压力区间", text_color=color.white, text_size=size.small)
    
    table.cell(infoTable, 0, 5, "----", text_color=swingBullishOrderBlockColor_trend, text_size=size.small, bgcolor=swingBullishOrderBlockColor_trend)
    table.cell(infoTable, 1, 5, "支撑区间", text_color=color.white, text_size=size.small)
