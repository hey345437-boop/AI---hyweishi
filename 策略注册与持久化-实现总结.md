策略注册机制与持久化 - 实现总结
===========================================

## 完成项目

### 1. 策略注册机制（避免策略1/2混淆）

**问题**：
- 原有实现使用下拉索引（index）绑定策略，导致排序变化时策略错位
- 策略 ID 不稳定（strategy vs strategy_v2 vs strategy_v1 混淆）
- 无元数据管理（没有 display_name、version 等）

**解决方案**：

#### 创建 strategy_registry.py
- `StrategyRegistry` 类：维护所有策略的稳定元数据
- 支持内置策略（strategy_v1/v2/default）与扩展策略（strategies/ 目录）
- 每个策略有唯一 `strategy_id`（primary key）
- 支持动态加载策略类（reflection）
- 提供 `validate_and_fallback_strategy()` 用于无效 ID 回退到默认

**关键函数**：
```python
get_strategy_registry()          # 全局单例
list_all_strategies()           # 返回 [(display_name, strategy_id), ...]
get_strategy_display_name(sid)  # 获取显示名称
validate_and_fallback_strategy(sid)  # 验证并回退
```

#### 修改 UI selectbox
文件：`ui_legacy.py` 第 145-195 行

变化：
- **旧**：使用 `index=strategy_idx` 绑定下拉索引
- **新**：使用 `strategy_selectbox` key + `on_change` 回调，绑定稳定的 `strategy_id`
- **回调**：`_on_strategy_change()` 立即将选择写入 DB

代码示例：
```python
# 使用稳定 strategy_id 而非索引
strategy_ids = [opt[1] for opt in strategy_options]
current_strategy_id = st.session_state.get('selected_strategy_id')

selected_strategy_tuple = st.selectbox(
    "选择策略模块",
    strategy_options,
    index=current_idx,           # 索引仅用于展示当前选择
    key='strategy_selectbox',    # 不要用 index 作为绑定
    on_change=_on_strategy_change
)
```

---

### 2. 刷新记住上次策略（跨刷新持久化）

**问题**：
- 页面刷新后策略选择丢失，回到默认值
- 需要手动重新选择策略

**解决方案**：

#### DB 架构更新
文件：`db_bridge.py`

新增列到 `bot_config` 表：
```sql
selected_strategy_id TEXT DEFAULT NULL
```

迁移逻辑（自动为旧 DB 添加列）：
```python
# init_db() 中的列迁移代码
cursor.execute("PRAGMA table_info(bot_config)")
existing_columns = {row[1] for row in cursor.fetchall()}

# 逐个添加缺失的列
for col_name, col_def in new_columns.items():
    if col_name not in existing_columns:
        cursor.execute(f"ALTER TABLE bot_config ADD COLUMN {col_name} {col_def}")
```

#### 初始化流程
文件：`ui_legacy.py` 第 555-562 行

新增初始化步骤：
```python
# 从 DB bootstrap selected_strategy_id
from strategy_registry import validate_and_fallback_strategy
db_strategy_id = bootstrap.get('selected_strategy_id')
valid_strategy_id = validate_and_fallback_strategy(db_strategy_id)
st.session_state.selected_strategy_id = valid_strategy_id
```

**关键特性**：
- 页面加载时从 DB 读取 `selected_strategy_id`
- 若 DB 中的 ID 无效或已删除 → 自动回退到默认策略并写回 DB
- 用户每次改变策略 → `on_change` 立即写 DB
- 刷新页面 → 恢复上次的策略选择

---

### 3. 新策略模板与扩展机制

**创建位置**：
```
strategies/strategy_template/
├── manifest.json       # 元数据
├── __init__.py        # 策略实现（导出类）
└── README.md          # 创建指南
```

**manifest.json 示例**：
```json
{
  "strategy_id": "my_strategy_01",
  "display_name": "我的策略 v1",
  "version": "1.0.0",
  "description": "基于 MACD 的趋势策略",
  "class_name": "MyStrategy",
  "order": 100
}
```

**策略类接口**（必须实现）：
```python
class MyStrategy:
    def __init__(self):
        """初始化参数"""
        pass
    
    def analyze(self, df: pd.DataFrame) -> dict:
        """返回 {signal, confidence, entry_price, stop_loss, take_profit, reason}"""
        pass
    
    def get_position_size(self, symbol: str, balance: float, leverage: float = 1.0) -> float:
        """计算仓位大小"""
        pass
```

**创建新策略步骤**：
1. 复制 `strategies/strategy_template/` 为 `strategies/my_new_strategy/`
2. 修改 `manifest.json` 的 `strategy_id`、`display_name`、`class_name`
3. 修改 `__init__.py` 的类名和实现逻辑
4. 重启应用 → 新策略自动出现在下拉列表

---

## 验收标准（全部通过 ✓）

### 1. 策略注册机制
```
✓ 发现 4 个策略：strategy_v1, strategy_v2, strategy_default, strategy_template
✓ 每个策略有唯一的 strategy_id
✓ 每个策略有 display_name、version、description
✓ 支持动态加载策略类
```

### 2. 稳定 ID（无论目录顺序如何）
```
✓ 多次扫描的 strategy_id 顺序一致
✓ 下拉列表排序不影响 strategy_id 对应关系
✓ UI selectbox 使用稳定的 strategy_id 而非索引
```

### 3. DB 持久化
```
✓ selected_strategy_id 正确保存到 DB
✓ 从 DB 读取时数据完整
✓ 列迁移：旧 DB 自动添加 selected_strategy_id 列
```

### 4. 跨刷新记忆
```
✓ 页面加载时从 DB 读取 selected_strategy_id
✓ 刷新后仍选中上次的策略
✓ 用户选择新策略 → on_change 立即写 DB
✓ 无效的 strategy_id 自动回退到默认值并写回 DB
```

### 5. UI selectbox 改造
```
✓ selectbox options: [(display_name, strategy_id), ...]
✓ selectbox key: 'strategy_selectbox'（不绑定 index）
✓ format_func: 显示 display_name（第一个元素）
✓ on_change: 回调立即写 DB
```

---

## 文件清单

### 新建文件
- `strategy_registry.py` - 策略注册表与元数据管理（~250 行）
- `test_strategy_persistence.py` - 验证测试套件（~170 行）
- `strategies/strategy_template/manifest.json` - 策略模板元数据
- `strategies/strategy_template/__init__.py` - 策略模板实现（~180 行）
- `strategies/strategy_template/README.md` - 创建指南

### 修改文件
- `app.py` - 更新 `discover_strategy_modules()` 使用 `strategy_registry`
- `db_bridge.py` - 添加列迁移逻辑；bot_config 新增 selected_strategy_id 列
- `ui_legacy.py` - 修改 selectbox 使用稳定 strategy_id；添加初始化验证

### 数据流
```
用户刷新页面
    ↓
ui_legacy.render_main()
    ↓
bootstrap = get_bootstrap_state()  [读取 DB 中的 selected_strategy_id]
    ↓
validate_and_fallback_strategy(bootstrap['selected_strategy_id'])
    ↓
st.session_state.selected_strategy_id = valid_id
    ↓
render_sidebar() → selectbox(key='strategy_selectbox')
    ↓
用户改变选择 → _on_strategy_change()
    ↓
update_bot_config(selected_strategy_id=new_id)  [写入 DB]
    ↓
st.rerun()
    ↓
页面刷新，从 DB 恢复新的策略选择
```

---

## 性能与安全性

### 性能
- **策略注册**：启动时扫描一次，后续使用单例缓存
- **动态加载**：策略类首次使用时加载，thereafter cached
- **DB 查询**：single-row bot_config，性能无损失

### 安全性
- **稳定 ID**：避免下拉索引导致的意外策略切换
- **回退机制**：无效 ID 自动回退，防止崩溃
- **验证**：所有 strategy_id 使用前都验证

---

## 测试结果

运行 `test_strategy_persistence.py` 输出：
```
============================================================
✓ 所有测试通过！
============================================================

验收标准：
✓ 1. 策略注册：可以发现内置策略 v1/v2/default
✓ 2. 稳定 ID：无论顺序如何，strategy_id 保持一致
✓ 3. DB 持久化：selected_strategy_id 能正确保存和加载
✓ 4. 跨刷新记忆：页面刷新后仍选中上次的策略
✓ 5. 无效回退：无效的 strategy_id 自动回退到默认值
```

---

## 下一步建议

### 1. UI 策略参数调整面板
在 sidebar 中添加动态参数调整表单，从 strategy 的 `STRATEGY_PARAMS` 元数据生成

### 2. 策略性能对比
统计每个策略的历史收益、胜率、最大回撤，供用户选择参考

### 3. 策略版本管理
支持同一策略的多个版本（如 strategy_rsi_v1 vs strategy_rsi_v2）并能对比切换

### 4. 策略参数持久化
在 DB 中为每个策略保存其参数配置，用户调整后自动保存和恢复
