//@version=6
indicator("主流币种中长线", overlay=true)

// =================================================================
//                  辅助提示模式 (顶底 - 保持不变)
// =================================================================

// 1. 信号模式选择
copy_modeInput = input.string("平衡模式", title="辅助提示模式", 
     options=["保守模式", "平衡模式", "激进模式", "恶魔模式"], 
     group="=== 顶底提示 ===")

// 2. 实时模式开关
copy_realTimeMode = input.bool(false, title="启用实时显示信号", 
     group="=== 顶底提示 ===")

// 逻辑映射
var bool copy_more = false
var int copy_choose = 1

switch copy_modeInput
    "保守模式" => 
        copy_more := false
        copy_choose := 0 
    "平衡模式" => 
        copy_more := true
        copy_choose := 1
    "激进模式" => 
        copy_more := true
        copy_choose := 2
    "恶魔模式" => 
        copy_more := true
        copy_choose := 3

// ———— Stoch + KDJ ————
int copy_periodK = 14
int copy_smoothK = 5
int copy_overSoldLevel = 20
int copy_overBoughtLevel = 80
int copy_ilong = 9
int copy_isig = 3

copy_k = ta.sma(ta.stoch(close, high, low, copy_periodK), copy_smoothK)

copy_bcwsma(series, length, m) =>
    float _bcwsma = na
    _bcwsma := (m * series + (length - m) * nz(_bcwsma[1])) / length

copy_rsv = 100 * (close - ta.lowest(low, copy_ilong)) / (ta.highest(high, copy_ilong) - ta.lowest(low, copy_ilong))
copy_pK = copy_bcwsma(copy_rsv, copy_isig, 1)
copy_pD = copy_bcwsma(copy_pK, copy_isig, 1)

copy_stochOversold = copy_k < copy_overSoldLevel  
copy_stochOverbought = copy_k > copy_overBoughtLevel  
copy_kdj_golden_cross = ta.crossover(copy_pK, copy_pD)  
copy_kdj_death_cross = ta.crossunder(copy_pK, copy_pD)  

copy_smi_kdj_buy = copy_stochOversold and copy_kdj_golden_cross  
copy_smi_kdj_sell = copy_stochOverbought and copy_kdj_death_cross  

// ==================== OBV-ADX  ====================
copy_len = 22
copy_lensig = 22

copy_up = ta.change(ta.obv)
copy_down = -ta.change(ta.obv)
copy_plusDM = na(copy_up) ? na : copy_up > copy_down and copy_up > 0 ? copy_up : 0
copy_minusDM = na(copy_down) ? na : copy_down > copy_up and copy_down > 0 ? copy_down : 0
copy_trur = ta.rma(ta.stdev(ta.obv, copy_len), copy_len)
copy_plus = fixnan(100 * ta.ema(copy_plusDM, copy_len) / copy_trur)
copy_minus = fixnan(100 * ta.ema(copy_minusDM, copy_len) / copy_trur)
copy_sum = copy_plus + copy_minus
copy_adx = 100 * ta.ema(math.abs(copy_plus - copy_minus) / (copy_sum == 0 ? 1 : copy_sum), copy_lensig)

copy_obv_adx_buy = copy_minus >= 22 and copy_adx >= 22 and copy_plus <= 18  
copy_obv_adx_sell = copy_plus >= 22 and copy_minus <= 18 and copy_adx >= 22 

// ==================== 辅助组合信号 ====================
copy_triggerState = copy_realTimeMode ? true : barstate.isconfirmed

copy_basic_buy_signal = copy_triggerState and copy_smi_kdj_buy and copy_obv_adx_buy
copy_basic_sell_signal = copy_triggerState and copy_smi_kdj_sell and copy_obv_adx_sell

var int copy_obv_buy_bar = na
var int copy_obv_sell_bar = na

if copy_triggerState and copy_obv_adx_buy
    copy_obv_buy_bar := bar_index
if copy_triggerState and copy_obv_adx_sell
    copy_obv_sell_bar := bar_index

copy_extended_buy_signal = false
copy_extended_sell_signal = false

if copy_more
    copy_extended_buy_signal := copy_triggerState and copy_smi_kdj_buy and not na(copy_obv_buy_bar) and (bar_index - copy_obv_buy_bar) <= copy_choose
    copy_extended_sell_signal := copy_triggerState and copy_smi_kdj_sell and not na(copy_obv_sell_bar) and (bar_index - copy_obv_sell_bar) <= copy_choose

copy_combined_buy_signal = copy_basic_buy_signal or copy_extended_buy_signal
copy_combined_sell_signal = copy_basic_sell_signal or copy_extended_sell_signal

if copy_combined_buy_signal
    label.new(bar_index, low, "底", color=color.green, textcolor=color.white, style=label.style_label_up, yloc=yloc.belowbar)
    
if copy_combined_sell_signal
    label.new(bar_index, high, "顶", color=color.red, textcolor=color.white, style=label.style_label_down, yloc=yloc.abovebar)

// 辅助信号警报
copy_msg_buy = "底" + (copy_realTimeMode ? "[实时]" : "[收盘]") + "，价格: " + str.tostring(close)
copy_msg_sell = "顶" + (copy_realTimeMode ? "[实时]" : "[收盘]") + "，价格: " + str.tostring(close)

if copy_combined_buy_signal
    alert(copy_msg_buy, copy_realTimeMode ? alert.freq_once_per_bar : alert.freq_once_per_bar_close)
if copy_combined_sell_signal
    alert(copy_msg_sell, copy_realTimeMode ? alert.freq_once_per_bar : alert.freq_once_per_bar_close)


// =================================================================
//                      原策略：趋势1 部分 (移除TP/SL UI)
// =================================================================

tradeMode = input.string("多空双做", title="交易模式", options=["多空双做", "仅开多单", "仅开空单"], group="===策略设置===")
realTimeTradeMode = input.bool(false, title="启用实时交易信号", group="===策略设置===")

// 警报设置
enableAlerts = input.bool(true, "启用交易警报", group="警报设置")
alertPrefix = input.string("TRADE_INDICATOR", "警报前缀", group="===警报设置===")

// 震荡过滤器
oscillatorFilter = input(true, title="启用震荡过滤器", group="===震荡过滤器===")
oscillatorLength = input.int(20, title="振荡器长度(阈值)", minval=1, group="===震荡过滤器===")

// 计算逻辑 (保持不变)
len = 14
TrueRange = math.max(math.max(high - low, math.abs(high - nz(close[1]))), math.abs(low - nz(close[1])))
DirectionalMovementPlus = (high - nz(high[1])) > (nz(low[1]) - low) ? math.max(high - nz(high[1]), 0) : 0
DirectionalMovementMinus = (nz(low[1]) - low) > (high - nz(high[1])) ? math.max(nz(low[1]) - low, 0) : 0
var float SmoothedTrueRange = 0.0
SmoothedTrueRange := nz(SmoothedTrueRange[1]) - (nz(SmoothedTrueRange[1]) / len) + TrueRange
var float SmoothedDirectionalMovementPlus = 0.0
SmoothedDirectionalMovementPlus := nz(SmoothedDirectionalMovementPlus[1]) - (nz(SmoothedDirectionalMovementPlus[1]) / len) + DirectionalMovementPlus
var float SmoothedDirectionalMovementMinus = 0.0
SmoothedDirectionalMovementMinus := nz(SmoothedDirectionalMovementMinus[1]) - (nz(SmoothedDirectionalMovementMinus[1]) / len) + DirectionalMovementMinus
DIPlus = SmoothedDirectionalMovementPlus / SmoothedTrueRange * 100
DIMinus = SmoothedDirectionalMovementMinus / SmoothedTrueRange * 100
DX = math.abs(DIPlus - DIMinus) / (DIPlus + DIMinus) * 100
ADX = ta.wma(DX, len)
adxSlope = ADX - ADX[1]
trendMarket = ADX > oscillatorLength and adxSlope > 0

// 均线趋势
ma12 = ta.ema(close, 12)
ma144 = ta.ema(close, 144)
ma169 = ta.ema(close, 169)
trendUp = ma12 > ma144 and ma12 > ma169
trendDown = ma12 < ma144 and ma12 < ma169

// RSI 过滤
rsiVal = ta.rsi(close, 14)
isRsiNeutral = rsiVal >= 45 and rsiVal <= 55

// 策略1信号
[macdLine6, signalLine6, hist6] = ta.macd(close, 12, 26, 9)
macdGolden6 = ta.crossover(macdLine6, signalLine6)
macdDeath6 = ta.crossunder(macdLine6, signalLine6)
cciVal6 = ta.cci(close, 55)
cciAbove100_6 = cciVal6 > 100
cciBelowNeg100_6 = cciVal6 < -100
buyCondition6 = (oscillatorFilter ? trendMarket : true) and trendUp and macdGolden6 and cciAbove100_6 and not isRsiNeutral
sellCondition6 = (oscillatorFilter ? trendMarket : true) and trendDown and macdDeath6 and cciBelowNeg100_6 and not isRsiNeutral

// 策略2信号
[macdLine5, signalLine5, hist5] = ta.macd(close, 6, 13, 5)
macdGolden5 = ta.crossover(macdLine5, signalLine5)
macdDeath5 = ta.crossunder(macdLine5, signalLine5)
cciVal5 = ta.cci(close, 144)
cciAbove100_5 = cciVal5 > 100
cciBelowNeg100_5 = cciVal5 < -100
buyCondition5 = (oscillatorFilter ? trendMarket : true) and trendUp and macdGolden5 and cciAbove100_5 and not isRsiNeutral
sellCondition5 = (oscillatorFilter ? trendMarket : true) and trendDown and macdDeath5 and cciBelowNeg100_5 and not isRsiNeutral

// 整合交易信号
tradeTriggerState = realTimeTradeMode ? true : barstate.isconfirmed
buyConditionRaw = buyCondition6 or buyCondition5
sellConditionRaw = sellCondition6 or sellCondition5
buyCondition = tradeTriggerState and buyConditionRaw
sellCondition = tradeTriggerState and sellConditionRaw

// 信号标记绘制
plotshape(buyCondition6 and tradeTriggerState and (tradeMode == "多空双做" or tradeMode == "仅开多单"), location=location.belowbar, color=color.green, style=shape.circle, size=size.tiny, title="多单信号1")
plotshape(buyCondition5 and tradeTriggerState and (tradeMode == "多空双做" or tradeMode == "仅开多单"), location=location.belowbar, color=color.green, style=shape.circle, size=size.tiny, title="多单信号2")
plotshape(sellCondition6 and tradeTriggerState and (tradeMode == "多空双做" or tradeMode == "仅开空单"), location=location.abovebar, color=color.red, style=shape.circle, size=size.tiny, title="空单信号1")
plotshape(sellCondition5 and tradeTriggerState and (tradeMode == "多空双做" or tradeMode == "仅开空单"), location=location.abovebar, color=color.red, style=shape.circle, size=size.tiny, title="空单信号2")


// ====================== SMC 订单块 (核心逻辑保持不变，仅隐藏非必要UI) ======================
BULLISH_LEG = 1
BEARISH_LEG = 0
BULLISH = +1
BEARISH = -1
COLORED = 'Colored'
MONOCHROME = 'Monochrome'
ALL = 'All'
BOS = 'BOS'
CHOCH = 'CHoCH'
TINY = size.tiny
SMALL = size.small
NORMAL = size.normal
ATR = 'Atr'
RANGE = 'Cumulative Mean Range'
CLOSE = 'Close'
HIGHLOW = 'High/Low'
GREEN = #089981
RED = #F23645
MONO_BULLISH = #b2b5be
MONO_BEARISH = #5d606b

// --- 保留的UI选项 ---
showInternalsInput = input.bool(false, '显示内部结构', group="===SMC-结构/订单块===")
internalFilterConfluenceInput = input.bool(false, '内部结构共振过滤', group="===SMC-结构/订单块===")
showStructureInput = input.bool(false, '显示摆动结构', group="===SMC-结构/订单块===")
showInternalOrderBlocksInput = input.bool(false, '显示内部订单块', group="===SMC-结构/订单块===")
showSwingOrderBlocksInput = input.bool(true, '显示摆动订单块', group="===SMC-结构/订单块===")
swingOBWidthAdjust = input.bool(true, '启用摆动订单块宽度调节', group="===SMC-结构/订单块===")
swingOBWidthMultiplier = input.float(0.1, '宽度调节倍数(ATR)', step=0.05, minval=0.0, maxval=2.0, group="===SMC-结构/订单块===")

// --- 隐藏的参数 (硬编码为原默认值) ---
// 如果需要修改参数逻辑，请在这里修改，不要删除逻辑代码
styleInput = COLORED 
showInternalBullInput = ALL
internalBullColorInput = GREEN
showInternalBearInput = ALL
internalBearColorInput = RED
internalStructureSize = TINY
showSwingBullInput = ALL
swingBullColorInput = GREEN
showSwingBearInput = ALL
swingBearColorInput = RED
swingStructureSize = SMALL
swingsLengthInput = 50  // 原默认值
internalOrderBlocksSizeInput = 5 // 原默认值
swingOrderBlocksSizeInput = 5 // 原默认值
orderBlockFilterInput = ATR
orderBlockMitigationInput = HIGHLOW
internalBullishOrderBlockColor = color.new(#3179f5, 80)
internalBearishOrderBlockColor = color.new(#f77c80, 80)
swingBullishOrderBlockColor = color.new(#1848cc, 80)
swingBearishOrderBlockColor = color.new(#b22833, 80)


type pivot
    float currentLevel
    float lastLevel
    bool crossed
    int barTime
    int barIndex

type trend
    int bias

type orderBlock
    float barHigh
    float barLow
    int barTime
    int bias

var pivot swingHigh = pivot.new(na, na, false, na, na)
var pivot swingLow = pivot.new(na, na, false, na, na)
var pivot internalHigh = pivot.new(na, na, false, na, na)
var pivot internalLow = pivot.new(na, na, false, na, na)
var trend swingTrend = trend.new(0)
var trend internalTrend = trend.new(0)

var array<float> parsedHighs = array.new<float>()
var array<float> parsedLows = array.new<float>()
var array<int> times = array.new<int>()
var array<orderBlock> swingOrderBlocks = array.new<orderBlock>()
var array<orderBlock> internalOrderBlocks = array.new<orderBlock>()
var array<box> swingOrderBlocksBoxes = array.new<box>()
var array<box> internalOrderBlocksBoxes = array.new<box>()

var swingBullishColor = styleInput == MONOCHROME ? MONO_BULLISH : swingBullColorInput
var swingBearishColor = styleInput == MONOCHROME ? MONO_BEARISH : swingBearColorInput

if barstate.isfirst
    if showSwingOrderBlocksInput
        for i = 1 to swingOrderBlocksSizeInput
            swingOrderBlocksBoxes.push(box.new(na, na, na, na, xloc=xloc.bar_time, extend=extend.right))
    if showInternalOrderBlocksInput
        for i = 1 to internalOrderBlocksSizeInput
            internalOrderBlocksBoxes.push(box.new(na, na, na, na, xloc=xloc.bar_time, extend=extend.right))

atrMeasure = ta.atr(200)
volatilityMeasure = orderBlockFilterInput == ATR ? atrMeasure : ta.cum(ta.tr) / bar_index
highVolatilityBar = (high - low) >= (2 * volatilityMeasure)
parsedHigh = highVolatilityBar ? low : high
parsedLow = highVolatilityBar ? high : low
parsedHighs.push(parsedHigh)
parsedLows.push(parsedLow)
times.push(time)

leg(int size) =>
    var theLeg = 0
    newLegHigh = high[size] > ta.highest(size)
    newLegLow = low[size] < ta.lowest(size)
    if newLegHigh
        theLeg := BEARISH_LEG
    else if newLegLow
        theLeg := BULLISH_LEG
    theLeg

startOfNewLeg(int l) => ta.change(l) != 0
startOfBearishLeg(int l) => ta.change(l) == -1
startOfBullishLeg(int l) => ta.change(l) == +1

getCurrentStructure(int size, bool internal) =>
    currentLeg = leg(size)
    newPivot = startOfNewLeg(currentLeg)
    pivotLow = startOfBullishLeg(currentLeg)
    pivotHigh = startOfBearishLeg(currentLeg)
    if newPivot
        if pivotLow
            if internal
                internalLow.lastLevel := internalLow.currentLevel
                internalLow.currentLevel := low[size]
                internalLow.crossed := false
                internalLow.barTime := time[size]
                internalLow.barIndex := bar_index[size]
            else
                swingLow.lastLevel := swingLow.currentLevel
                swingLow.currentLevel := low[size]
                swingLow.crossed := false
                swingLow.barTime := time[size]
                swingLow.barIndex := bar_index[size]
        else
            if internal
                internalHigh.lastLevel := internalHigh.currentLevel
                internalHigh.currentLevel := high[size]
                internalHigh.crossed := false
                internalHigh.barTime := time[size]
                internalHigh.barIndex := bar_index[size]
            else
                swingHigh.lastLevel := swingHigh.currentLevel
                swingHigh.currentLevel := high[size]
                swingHigh.crossed := false
                swingHigh.barTime := time[size]
                swingHigh.barIndex := bar_index[size]

drawStructure(bool isHigh, bool internal, string tag, color structureColor, string labelSize) =>
    var line l = line.new(na, na, na, na, xloc=xloc.bar_time, color=structureColor, style=internal ? line.style_dashed : line.style_solid)
    var label lb = label.new(na, na, xloc=xloc.bar_index, text=tag, color=color.new(structureColor, 100), textcolor=structureColor, style=isHigh ? label.style_label_down : label.style_label_up, size=labelSize)
    if internal
        if isHigh
            line.set_xy1(l, internalHigh.barTime, internalHigh.currentLevel)
            line.set_xy2(l, time, internalHigh.currentLevel)
            label.set_xy(lb, math.round(0.5*(internalHigh.barIndex+bar_index)), internalHigh.currentLevel)
        else
            line.set_xy1(l, internalLow.barTime, internalLow.currentLevel)
            line.set_xy2(l, time, internalLow.currentLevel)
            label.set_xy(lb, math.round(0.5*(internalLow.barIndex+bar_index)), internalLow.currentLevel)
    else
        if isHigh
            line.set_xy1(l, swingHigh.barTime, swingHigh.currentLevel)
            line.set_xy2(l, time, swingHigh.currentLevel)
            label.set_xy(lb, math.round(0.5*(swingHigh.barIndex+bar_index)), swingHigh.currentLevel)
        else
            line.set_xy1(l, swingLow.barTime, swingLow.currentLevel)
            line.set_xy2(l, time, swingLow.currentLevel)
            label.set_xy(lb, math.round(0.5*(swingLow.barIndex+bar_index)), swingLow.currentLevel)

storeOrdeBlock(bool isHighBreak, bool internal, int bias) =>
    if (internal and showInternalOrderBlocksInput) or (not internal and showSwingOrderBlocksInput)
        int baseIndex = isHighBreak ? (internal ? internalHigh.barIndex : swingHigh.barIndex) : (internal ? internalLow.barIndex : swingLow.barIndex)
        array<float> arr = na
        int parsedIndex = na
        if bias == BEARISH
            arr := parsedHighs.slice(baseIndex, bar_index)
            parsedIndex := baseIndex + arr.indexof(arr.max())
        else
            arr := parsedLows.slice(baseIndex, bar_index)
            parsedIndex := baseIndex + arr.indexof(arr.min())
        
        float originalHigh = parsedHighs.get(parsedIndex)
        float originalLow = parsedLows.get(parsedIndex)
        
        float finalHigh = originalHigh
        float finalLow = originalLow
        
        if not internal and swingOBWidthAdjust
            float expansion = atrMeasure * swingOBWidthMultiplier
            finalHigh := originalHigh + expansion
            finalLow := originalLow - expansion
        
        orderBlock ob = orderBlock.new(finalHigh, finalLow, times.get(parsedIndex), bias)
        array<orderBlock> target = internal ? internalOrderBlocks : swingOrderBlocks
        if target.size() >= 100
            target.pop()
        target.unshift(ob)

bearishOrderBlockMitigationSource = orderBlockMitigationInput == CLOSE ? close : high
bullishOrderBlockMitigationSource = orderBlockMitigationInput == CLOSE ? close : low

deleteOrderBlocks(bool internal=false) =>
    array<orderBlock> obs = internal ? internalOrderBlocks : swingOrderBlocks
    for [idx, ob] in obs
        crossed = false
        if bearishOrderBlockMitigationSource > ob.barHigh and ob.bias == BEARISH
            crossed := true
        else if bullishOrderBlockMitigationSource < ob.barLow and ob.bias == BULLISH
            crossed := true
        if crossed
            obs.remove(idx)

drawOrderBlocks(bool internal=false) =>
    array<orderBlock> obs = internal ? internalOrderBlocks : swingOrderBlocks
    n = obs.size()
    if n > 0
        maxN = internal ? internalOrderBlocksSizeInput : swingOrderBlocksSizeInput
        int n = math.min(maxN, n)
        array<orderBlock> slice = obs.slice(0, n)
        array<box> pool = internal ? internalOrderBlocksBoxes : swingOrderBlocksBoxes
        for i = 0 to n - 1
            orderBlock ob = slice.get(i)
            color c = na
            if styleInput == MONOCHROME
                c := ob.bias == BEARISH ? color.new(MONO_BEARISH, 80) : color.new(MONO_BULLISH, 80)
            else
                if internal
                    c := ob.bias == BEARISH ? internalBearishOrderBlockColor : internalBullishOrderBlockColor
                else
                    c := ob.bias == BEARISH ? swingBearishOrderBlockColor : swingBullishOrderBlockColor
            box b = pool.get(i)
            b.set_top_left_point(chart.point.new(ob.barTime, na, ob.barHigh))
            b.set_bottom_right_point(chart.point.new(last_bar_time, na, ob.barLow))
            b.set_border_color(internal ? na : c)
            b.set_bgcolor(c)
            
            if not internal
                midTime = (ob.barTime + last_bar_time) / 2
                midPrice = (ob.barHigh + ob.barLow) / 2
                labelText = ob.bias == BEARISH ? "压力" : "支撑"
                labelColor = ob.bias == BEARISH ? color.red : color.green
                label.new(midTime, midPrice, text=labelText, xloc=xloc.bar_time, yloc=yloc.price, 
                          color=color(na), textcolor=labelColor, style=label.style_label_center, size=size.small)

displayStructure(bool internal=false) =>
    var bullishBar = true
    var bearishBar = true
    if internal and internalFilterConfluenceInput
        bullishBar := high - math.max(close, open) > math.min(close, open - low)
        bearishBar := high - math.max(close, open) < math.min(close, open - low)
    float highLevel = internal ? internalHigh.currentLevel : swingHigh.currentLevel
    bool highCross = ta.crossover(close, highLevel)
    bool highNotCrossed = internal ? not internalHigh.crossed : not swingHigh.crossed
    bool extraUp = internal ? (internalHigh.currentLevel != swingHigh.currentLevel and bullishBar) : true
    if highCross and highNotCrossed and extraUp
        string tag = (internal ? internalTrend.bias : swingTrend.bias) == BEARISH ? CHOCH : BOS
        if internal
            internalHigh.crossed := true
            internalTrend.bias := BULLISH
        else
            swingHigh.crossed := true
            swingTrend.bias := BULLISH
        bool displayCond = false
        if internal
            displayCond := showInternalsInput and (showInternalBullInput == ALL or (showInternalBullInput == BOS and tag != CHOCH) or (showInternalBullInput == CHOCH and tag == CHOCH))
        else
            displayCond := showStructureInput and (showSwingBullInput == ALL or (showSwingBullInput == BOS and tag != CHOCH) or (showSwingBullInput == CHOCH and tag == CHOCH))
        if displayCond
            drawStructure(true, internal, tag, styleInput == MONOCHROME ? MONO_BULLISH : (internal ? internalBullColorInput : swingBullColorInput), internal ? internalStructureSize : swingStructureSize)
        if (internal and showInternalOrderBlocksInput) or (not internal and showSwingOrderBlocksInput)
            storeOrdeBlock(true, internal, BULLISH)

    float lowLevel = internal ? internalLow.currentLevel : swingLow.currentLevel
    bool lowCross = ta.crossunder(close, lowLevel)
    bool lowNotCrossed = internal ? not internalLow.crossed : not swingLow.crossed
    bool extraDn = internal ? (internalLow.currentLevel != swingLow.currentLevel and bearishBar) : true
    if lowCross and lowNotCrossed and extraDn
        string tag2 = (internal ? internalTrend.bias : swingTrend.bias) == BULLISH ? CHOCH : BOS
        if internal
            internalLow.crossed := true
            internalTrend.bias := BEARISH
        else
            swingLow.crossed := true
            swingTrend.bias := BEARISH
        bool displayCond2 = false
        if internal
            displayCond2 := showInternalsInput and (showInternalBearInput == ALL or (showInternalBearInput == BOS and tag2 != CHOCH) or (showInternalBearInput == CHOCH and tag2 == CHOCH))
        else
            displayCond2 := showStructureInput and (showSwingBearInput == ALL or (showSwingBearInput == BOS and tag2 != CHOCH) or (showSwingBearInput == CHOCH and tag2 == CHOCH))
        if displayCond2
            drawStructure(false, internal, tag2, styleInput == MONOCHROME ? MONO_BEARISH : (internal ? internalBearColorInput : swingBearColorInput), internal ? internalStructureSize : swingStructureSize)
        if (internal and showInternalOrderBlocksInput) or (not internal and showSwingOrderBlocksInput)
            storeOrdeBlock(false, internal, BEARISH)

getCurrentStructure(swingsLengthInput, false)
getCurrentStructure(5, true)

if showInternalsInput or showInternalOrderBlocksInput
    displayStructure(true)
if showStructureInput or showSwingOrderBlocksInput
    displayStructure(false)
if showInternalOrderBlocksInput
    deleteOrderBlocks(true)
if showSwingOrderBlocksInput
    deleteOrderBlocks(false)

if barstate.islastconfirmedhistory or barstate.islast
    if showInternalOrderBlocksInput
        drawOrderBlocks(true)
    if showSwingOrderBlocksInput
        drawOrderBlocks(false)

// ====================== 警报价格计算逻辑 (新增) ======================
// 获取最近的摆动订单块价格
getPressurePrice() =>
    float nearestPx = na
    float minDist = na
    if swingOrderBlocks.size() > 0
        for i = 0 to swingOrderBlocks.size() - 1
            orderBlock ob = swingOrderBlocks.get(i)
            // 压力：Bias=Bearish (空头OB), 位于当前价格上方(Low > Close)
            if ob.bias == BEARISH and ob.barLow > close
                float dist = ob.barLow - close
                if na(minDist) or dist < minDist
                    minDist := dist
                    nearestPx := ob.barLow
    nearestPx

getSupportPrice() =>
    float nearestPx = na
    float minDist = na
    if swingOrderBlocks.size() > 0
        for i = 0 to swingOrderBlocks.size() - 1
            orderBlock ob = swingOrderBlocks.get(i)
            // 支撑：Bias=Bullish (多头OB), 位于当前价格下方(High < Close)
            if ob.bias == BULLISH and ob.barHigh < close
                float dist = close - ob.barHigh
                if na(minDist) or dist < minDist
                    minDist := dist
                    nearestPx := ob.barHigh
    nearestPx

// ====================== 警报逻辑 (更新) ======================
var bool hasAlertedLong = false
var bool hasAlertedShort = false

tradeAlertFreq = realTimeTradeMode ? alert.freq_once_per_bar : alert.freq_once_per_bar_close
alertSuffix = realTimeTradeMode ? " [实时]" : " [收盘]"

// 动态获取当前压力支撑
float p_price = getPressurePrice()
float s_price = getSupportPrice()
// 构建简洁的附加信息
string ps_msg = "\n压力: " + (na(p_price) ? "无" : str.tostring(p_price, "#.##")) + "，支撑: " + (na(s_price) ? "无" : str.tostring(s_price, "#.##"))

if buyCondition and not hasAlertedLong and enableAlerts
    alert_message = alertPrefix + ": 买入信号" + alertSuffix + "，价格: " + str.tostring(close, '#.####') + ps_msg
    alert(alert_message, tradeAlertFreq)
    hasAlertedLong := true
else if not buyCondition
    hasAlertedLong := false

if sellCondition and not hasAlertedShort and enableAlerts
    alert_message = alertPrefix + ": 卖出信号" + alertSuffix + "，价格: " + str.tostring(close, '#.####') + ps_msg
    alert(alert_message, tradeAlertFreq)
    hasAlertedShort := true
else if not sellCondition
    hasAlertedShort := false
